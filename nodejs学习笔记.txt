安装npm
curlhttp://npmjs.org/install.sh | sudo sh
多版本管理器n 类似ruby的rvm
npminstall -g n
通过n 获取的 Node.js 实例都会安装在 /usr/local/n/versions/ 目录中


#语言
1.创建一个http服务器
varhttp = require('http');
http.createServer(function(req,res) { 
 res.writeHead(200, {'Content-Type': 'text/html'}); 
 res.write('<h1>Node.js</h1>');
 res.end('<p>Hello World</p>');
}).listen(3000);
console.log("HTTPserver is listening at port 3000.");

listen创建了事件监听，node.js进程不会退出事件循环，所以进程会一直等待

2.supervisor
node.js的http会一次读入内存，修改文件要重启服务才可以查看修改，不像php每次会重新读一下脚本，所以要用supervisor,每次文件改动就会重启一下node
npminstall -g supervisor

3.node.js的异步I/O在完成时都会发送一个事件去事件队列，事件是由EventEmitter提供
//event.js
varEventEmitter = require('events').EventEmitter;
varevent = new EventEmitter();
event.on('some_event',function() { console.log('some_event occured.');
});
setTimeout(function(){ event.emit('some_event');
},1000);

node.js没有显式事件循环(对比ruby的EventMachine.run()),是由libev控制对开发者不可见的,libev事件循环的每一次迭代，在node.js里面就是一个tick，libev不断循环检查是否有活动事件，直到检测不到事件循环，才会结束进程

4.模块和包管理
使用require去请求一个js文件，require的可以是js代码，json或者c++扩展
a)创建和加载一个模块
Node.js提供了 exports 和 require 两个对 象,其中 exports 是模块公开的接口,require 用于从外部获取一个模块的接口,即所获 取模块的 exports 对象。
//module.js
varname;
exports.setName= function(thyName) { name = thyName;
};
exports.sayHello= function() { console.log('Hello ' + name);
};

//getmodule.js
varmyModule = require('./module');
myModule.setName('BYVoid');
myModule.sayHello();

b)要注意的是require只是单次加载，每次都会指向同一个实例
//loadmodule.js
varhello1 = require('./module'); hello1.setName('BYVoid');
varhello2 = require('./module'); hello2.setName('BYVoid 2');
hello1.sayHello();
//两次都是输出BYYoid 2

c)覆盖exports
//singleobject.js
functionHello() {
 var name;
 this.setName = function (thyName) { 
   name = thyName;
 };
 this.sayHello = function () { 
   console.log('Hello ' + name);
 };
}

exports.Hello= Hello; //这样使用时就要require('singleobject').Hello 很不方便
module.exports= Hello;
在外部引用该模块时,其接口对象就是要输出的Hello 对象本身,而不是原先的 exports。
事实上,exports本身仅仅是一个普通的空对象,即 {},它专门用来声明接口,本 质上是通过它为模块闭包1的内部建立了一个有限的访问接口。因为它没有任何特殊的地方, 所以可以用其他东西来代替,譬如我们上面例子中的 Hello 对象。

exports在模块执行结束之后会释放，module则不会，因此只能通过module.exports改变接口

4.创建包
Node.js的包是一个目录,其中包含一个 JSON 格式的包说明文件 package.json。严格符 合 CommonJS 规范的包应该具备以下特征:
a.package.json 必须在包的顶层目录下;  二进制文件应该在 bin 目录下;
b.JavaScript 代码应该在 lib 目录下;
c.文档应该在 doc 目录下;
d.单元测试应该在 test 目录下。

如果package.json 或 main 字段不存在,会尝试寻找 index.js 或 index.node 作 为包的接口。
package.json是 CommonJS 规定的用来描述包的文件,完全符合规范的 package.json 文 件应该含有以下字段。
a.name:包的名称,必须是唯一的,由小写英文字母、数字和下划线组成,不能包含 空格。
b.description:包的简要说明。
c.version:符合语义化版本识别1规范的版本字符串。
d.keywords:关键字数组,通常用于搜索。
e.maintainers:维护者数组,每个元素要包含 name、email (可选)、web (可选) 字段。
f.contributors:贡献者数组,格式与maintainers相同。包的作者应该是贡献者数组的第一个元素。
g.bugs:提交bug的地址,可以是网址或者电子邮件地址。
h.licenses:许可证数组,每个元素要包含 type (许可证的名称)和 url (链接到)
i.repositories:仓库托管地址数组,每个元素要包含 type(仓库的类型,如 git )、url (仓库的地址)和 path (相对于仓库的路径,可选)字段。

5.node.js 包管理 npm
install如果不加-g,会安装到当前目录 node_module下面
使用全局模式npm会将包安装到系统目录,譬如 /usr/local/lib/node_modules/,同时 package.json 文 件中 bin 字段包含的文件会被链接到 /usr/local/bin/, 使用全局模式的方法不能被require到，因为不会搜索/usr/bin

a.npm link
npm提供了一个有趣的命令 npm link,它的功能是在本地包和全局包之间创建符号链 接。我们说过使用全局模式安装的包不能直接通过 require 使用,但通过 npm link命令 可以打破这一限制。举个例子,我们已经通过 npm install -g express 安装了 express, 5 这时在工程的目录下运行命令:
 npm link express
./node_modules/express-> /usr/local/lib/node_modules/express
￼我们可以在node_modules 子目录中发现一个指向安装到全局的包的符号链接。通过这 种方法,我们就可以把全局包当本地包来使用了。

npmlink还可以把当前包链接到全局，方便其他项目引用开发中的包

b.包发布
搞好包后
1)npminit
2)npmadduser, npm whoami可以查看创建user是否成功
3)npmpublish
4)http://search.npmjs.org 有了后就可以npm install装他了
5)包有更新在package.jsversion修改在 npm publish一次
6)npmunpublish可以取消发布 

6.debug
nodedebug some.js
进入debug后的各种命令
run
restart
cont,c
next,n
step,s
out,o
setBreakpoint(),sb()
setBreakpoint(‘f()’),sb(...)
setBreakpoint(‘script.js’,20), sb(...)
clearBreakpoint,cb(...)
backtrace,bt
list(5)
watch(expr)
unwatch(expr)
watchers
repl
kill
scripts
version

b)　远程调试
启动调试服务器，默认端口是5858
node--debug[=port] script.js 
node--debug-brk[=port] script.js //这种方式在服务器启动时暂停脚本运行
客户端终端
nodedebug 127.0.0.1:5858

c)使用node-inspector去调试
npminstall -g node-inspector
然后启动一个debug服务器
node--debug-bkr debug.js
node-inspector
然后在浏览器用http://localhost:8080/debug?port=5858

#node.js核心模块
1.全局对象
在dom是window,在node.js里面是global

2.process是global对象里面一个属性，用于和操作系统交互
process.argv命令行参数祖
process.stdoutprocess.stdout.write()比console.log更底层
process.stdin标准输入流
 process.stdin.resume();
 process.stdin.on('data', function(data) { 
   process.stdout.write('read from console: ' + data.toString());
 });
process.nextTick(callback)为事件循环设置一个任务，再下次事件循环会执行callback
还有process.pidprocess.memoryUsage 等等

3.util核心函数库，弥补原来javascript的功能太少
a)util.inherits(constructor,superConstructor) 方便提供继承
varutil = require('util');
functionBase() { 
 this.name = 'base'; 
 this.base = 1991;
 this.sayHello = function() {
   console.log('Hello ' + this.name);
 };
}
Base.prototype.showName= function() { 
 console.log(this.name); 
};
functionSub() { 
 this.name = 'sub';
}
util.inherits(Sub,Base);
varobjBase = new Base();
objBase.showName();//base
objBase.sayHello();//hello base
console.log(objBase);

varobjSub = new Sub(); 
objSub.showName(); //sub
//objSub.sayHello();
console.log(objSub);//这里没有继承到 .base .sayHello

b)util.inspect(object,[showHidden],[depth],[colors])
将任意一个对象转成字符串，object就是要转换的对象

c)除了以上我们介绍的几个函数之外,util还提供了util.isArray()、util.isRegExp()、util.isDate()、util.isError() 四个类型测试工具,以及 util.format()、util. debug() 等工具

4.事件驱动 events
node.js里面最功能的一个模块，只有一个EventEmitter对象，可以注册多个事件
EventEmitter.on(event,listener) 为指定事件注册一个监听器,接受一个字 符串event和一个回调函数listener。
EventEmitter.emit(event,[arg1], [arg2], [...]) 发射 event 事件,传递若干可选参数到事件监听器的参数表。
EventEmitter.once(event,listener) 为指定事件注册一个单次监听器,即监听器最多只会触发一次,触发后立刻解除该监听器。
EventEmitter.removeListener(event,listener) 移除指定事件的某个监听器,listener 必须是该事件已经注册过的监听器。
EventEmitter.removeAllListeners([event])移除所有事件的所有监听器, 如果指定 event,则移除指定事件的所有监听器。

a)error事件
如果emit("error")的话会令程序崩溃

5.文件系统fs
fs模块提供了异步和同步的两个版本,例如读取文件内容的函数有异步的 fs.readFile() 和同步的 fs.readFileSync()

a)fs.readFile(filename,[encoding],[callback(err,data)])
varfs = require('fs');
fs.readFile('content.txt',function(err, data) {  //最好指定编码"utf-8"
 if (err) {
   console.error(err); 
 } else {
   console.log(data);
 }
});

同步版本,有错误的时候会抛异常，可以用try catch去接
file= fs.readFileSync(filename, [encoding])

b)fs.open
fs.open(path,flags,[mode], [callback(err, fd)])是POSIX open 函数的封装,与 C 语言标准库中的 fopen 函数类似。它接受两个必选参数,path 为文件的路径, flags 可以是以下值。
r:以读取模式打开文件。
r+ :以读写模式打开文件。
w:以写入模式打开文件,如果文件不存在则创建。
w+ :以读写模式打开文件,如果文件不存在则创建。
a :以追加模式打开文件,如果文件不存在则创建。
a+ :以读取追加模式打开文件,如果文件不存在则创建。
mode默认是0666, fd是一个文件引用的返回

c)fs.read
fs.read(fd, buffer, offset, length, position, [callback(err, bytesRead, buffer)])

6. http服务器
a)http.Server 是一个基于事件的 HTTP 服务器,所有的请求都被封装为独立的事件, 开发者只需要对它的事件编写响应函数即可实现 HTTP 服务器的所有功能。它继承自 EventEmitter,提供了以下几个事件。
request: 当客户端请求到来时,该事件被触发,提供两个参数 req 和res,分别是 http.ServerRequest和http.ServerResponse 的实例,表示请求和响应信息。
connection: 当 TCP 连接建立时,该事件被触发,提供一个参数 socket,为 net.Socket 的实例。connection 事件的粒度要大于 request,因为客户端在 Keep-Alive 模式下可能会在同一个连接内发送多次请求。
close: 当服务器关闭时,该事件被触发。注意不是在用户连接断开时。
除此之外还有 checkContinue、upgrade、clientError 事件,通常我们不需要关 心,只有在实现复杂的 HTTP 服务器的时候才会用到。

b)http.ServerRequest

c)获取get请求内容
var http = require('http'); 
var url = require('url');
var util = require('util');
http.createServer(function(req, res) {
  res.writeHead(200, {'Content-Type': 'text/plain'});
  res.end(util.inspect(url.parse(req.url, true)));
}).listen(3000);

d)获取post内容
//httpserverrequestpost.js
var http = require('http');
var querystring = require('querystring');
var util = require('util');
http.createServer(function(req, res) {
  var post = '';
  req.on('data', function(chunk) { 
    post += chunk; 
  });

  req.on('end', function() {
    post = querystring.parse(post); 
    res.end(util.inspect(post));
  });
}).listen(3000);

把post保存到 post字符串, 下面用querystring.parse把post弄出来，生产环境可不能用这么简单的方式去做

e)http.ServerResponse
三个用于返回头，内容，和结束的函数
 response.writeHead(statusCode, [headers]):向请求的客户端发送响应头。 statusCode 是 HTTP 状态码,如 200 (请求成功)、404 (未找到)等。headers 是一个类似关联数组的对象,表示响应头的每个属性。该函数在一个请求内最多只 能调用一次,如果不调用,则会自动生成一个响应头。
 response.write(data, [encoding]):向请求的客户端发送响应内容。data 是 一个 Buffer 或字符串,表示要发送的内容。如果 data 是字符串,那么需要指定 encoding 来说明它的编码方式,默认是 utf-8。在 response.end 调用之前, response.write 可以被多次调用。
 response.end([data], [encoding]):结束响应,告知客户端所有发送已经完 成。当所有要返回的内容发送完毕的时候,该函数 必须 被调用一次。它接受两个可 选参数,意义和 response.write 相同。如果不调用该函数,客户端将永远处于 等待状态。

f)http　客户端
http 模块提供了两个函数 http.request 和 http.get,功能是作为客户端向 HTTP 服务器发起请求。
http.request(options, callback) 发起 HTTP 请求。接受两个参数,option 是 一个类似关联数组的对象,表示请求的参数,callback 是请求的回调函数。option 常用的参数如下所示。
host :请求网站的域名或 IP 地址。
port :请求网站的端口,默认 80。
method :请求方法,默认是 GET。
path :请求的相对于根的路径,默认是“/”。QueryString 应该包含在其中。
  例如 /search?query=byvoid。
headers :一个关联数组对象,为请求头的内容。
callback 传递一个参数,为http.ClientResponse的实例。 http.request 返回一个http.ClientRequest的实例。
例子：
下面是一个通过 http.request 发送 POST 请求的代码: //httprequest.js
var http = require('http');
var querystring = require('querystring');
var contents = querystring.stringify({
  name: 'byvoid',
  email: 'byvoid@byvoid.com',
  address: 'Zijing 2#, Tsinghua University',

});
var options = {
  host: 'www.byvoid.com',
  path: '/application/node/post.php', method: 'POST',
  headers: {
    'Content-Type': 'application/x-www-form-urlencoded',
    'Content-Length' : contents.length
  }

};
var req = http.request(options, function(res) { 
  res.setEncoding('utf8');
  res.on('data', function (data) {
    console.log(data);
  });
});
req.write(contents);
req.end();

#用node.js做web开发, express
