# -*- coding: utf-8 -*-
如果原始碼裡出現UTF-8中文，檔案第一行必須加上# encoding: utf-8

第一章：ruby 快速上手
一 DOC
（1）RDoc 现在ruby已经可以类似javadoc，从源代码生成html文档
（2）ri 类名 //在命令行下使用ri命令可以查看类名文档

二 ruby OO
ruby是完全面向对象语言，即使所有基本类型的变量都可看做对象，这样带来了描述的各种简化，
例如需要求绝对值，在java中：
int num = -1234;
num = Math.abs(numb); //=>1234
而在ruby中：
num = -1234.abs //=>1234

三 基本语法
(1)每行结束无需分号，注释以#起头
方法: def 方法名()
      	 code...
     end
调用方法时可省略括号：如 puts 1234等同于puts(1234)

(2)字符串使用单引号和双引号的区别：使用单引号效率更好；使用双引号ruby背后会做些替换之类的工作，例如\n会变成换行，第二个用处是可以在双引号中直接镶嵌变量
name = eric
"fuck you #{name}" //=> fuck you eric

(3)ruby变量的定义方法
一般变量:name
成员变量：@name
类变量（静态变量）:@@name
全局变量:$name
类名:Name,MyClass(大写开头，驼峰标识)
常量：全大写 FUCK

(4)数组与hashes:
数组是索引数组：
a = [1,'a',3.14]
a[2]//=> 3.14
hashes是关联数组：
inst_section = {
'cello' => 'string',
'clarinet' => 'woodwind',
'drum' => 'percussion',
'oboe' => 'woodwind',
'trumpet' => 'brass',
'violin' => 'string'
}
inst_section['cello'] //=> woddwind

(5)symbol 类枚举用法
有些想指明为唯一值的标志型变量，如东南西北 east south west north,在ruby中可以直接以分号开头去声明，然后ruby保证该变量的唯一性
这个通常用在hashes的key中保证key的值是唯一
如上面hashes的例子就可以变成：
inst_section = {
:cello => 'string',
:clarinet => 'woodwind',
......
}
使用时：inst_section[:cello] //=>woddwind
symbol不是string:inst_section['cello']  //=>nil

ruby 1.9的新语法，在hashes中直接用 key:value声明则直接可以用symbol作为键值
如
inst_section = {
cello:'string',
clarinet:'woodwind'
}
使用：inst_section[:cello] //=>woddwind

（6）流程控制语句 if while for
ruby不用大括号，用end 来表示语句完结
if:
if today.saturday?
puts "Do chores around the house"
elsif today.sunday?
puts "Relax"
else
puts "Go to work"
end

注意elsif写法，不是elseif

while:
num_pallets = 101
weight = 1
while weight < 100 and num_pallets <= 30
      pallet = next_pallet()
      weight += pallet.weight
      num_pallets += 1
end

支持的另外一种 if 和 while的写法（类似perl）：
执行的语句 if 条件
执行的语句 while 条件

（7）regexp 正则表达式
ruby的正则表达式形式（和javascript相似）： /xxx/
用 =～去验证是否匹配字符串，如果匹配，会返回第一个匹配的字符串的下标位置，如果不匹配则返回nil
if time =~ /\d\d:\d\d:\d\d/
  puts "is time!!"
end

替换：
sub(正则,字符串) 
gsub(正则，字符串) #贪心模式
newline= line.sub(/Perl/, 'Ruby')# replace first 'Perl' with 'Ruby'
newerline = newline.gsub(/Python/, 'Ruby') # replace every 'Python' with 'Ruby'

（8）block 代码块
::在大括号或者 do end 之间的代码快
{puts "fuck block"}
或
do
  "fuck block"
  "fuck bolck2"
end

::单行用{};多行用 do end

::调用时，直接跟在方法调用后面
例如 greet(方法本来的参数) {puts "fuck"}

::yield:放在方法的代码块内，可看作是调用了之后传进来的block代码块
例子：
def call_block
  puts "Start of method"
  yield
  yield
  puts "End of method"
end
call_block { puts "In the block" }
#produces:
#Start of method
#In the block
#In the block
#End of method

::yield可以传参数到block里的变量，block里面的变量用|xxx|接收参数，例如yield('fuck'),{|xxx| puts xxx} //xxx=> fuck
def who_says_what
  yield("Dave", "hello")
  yield("Andy", "goodbye")
end
who_says_what {|person, phrase| puts "#{person} says #{phrase}"}
produces:
Dave says hello
Andy says goodbye

::block的用途，ruby本身的lib就用block去实现遍历（iterator）
animals = %w( ant bee cat dog elk )# create an array
animals.each {|animal| puts animal }# iterate over the contents

[ 'cat', 'dog', 'horse' ].each {|name| print name, " " }
5.times { print "*" } #对象5 调用了5次 block
3.upto(6) {|i| print i }#对象3 直到加到6 ，会print出每次增加到的数
('a'..'e').each {|char| print char } #遍历字母a到e的每个字母

四.IO基础
（1）print 不换行； puts 换行 ；p 换行，但是打印数组时会以[xx，xx]的形式打出,输出对象也用P比较好
（2）printf//参照C语言
printf("fuck that %s",'fuck you too'); //=> fuck that fuck you too
(3)gets 每次读一行，读到尾返回nil

五.命令行模式
（1）ruby运行脚本时接收参数
方法一：使用内置变量 ARGV,ARGV是一个数组，可用ARGV.size ARGV[1]等方法
方法二：使用ARGF,ARGF更为特殊，用于传入文件目录，ARGF会自动遍历好目录下的文件

--------------------------------------------------------------------------------------
第二章 ： 类  对象 变量
（1）对象定义：
：：成员变量前要加@,实际@xxx才是完整的成员变量名称
：：initialize()是构造方法
：：to_s是 相当于JAVA toString方法
：：attr_reader ，ruby提供的便利属性get方法，后面用:属性名，该属性就可以用 类名.属性 的形式访问，若多个，使用逗号隔开(:a,:b,:c)
：：attr_writer ，set方法，后面用 :属性名 表示该属性可以 用 类名.属性=新值 
：：attr_accessor ，get与set方法
class BookInStock
  attr_reader :isbn
  attr_accessor :price

  def initialize(isbn, price)
    @isbn = isbn
    @price = Float(price)
  end

  def to_s
    "ISBN: #{@isbn}, price: #{@price}"
  end

end


（2）对象里的虚拟属性（实际上是一个方法后加等于号，用户用上去就好像在使用属性一样）
class Man 
  attr_reader :age

  def initialize(age) 
    @age = age
  end

  def ageForWoman
    @age/2
  end

  def ageForWoman=(age)
    @age = age-10
  end 
end

man = Man.new(50)
p man.age #50
p man.ageForWoman #25
man.ageForWoman=30 
p man.ageForWoman #10

：：这样看上去，感觉就像在设置一个Man.ageForWoman的属性一样，但是实际上这是一个方法，可以用attr_xxx代替这种写法

（2.1）类方法（类似静态方法）
三种写法
a)def 类名.方法名
b)写在类外面，肯定不用
c)def self.方法名

（2.2）类常数
Version = '1.0'
外部用 类名::Version 访问

（2.3）类变量
@@变量名 就是定义了类变量，类外部要访问类变量的话要用写方法访问

(3)包引入
require 'csv' #引入ruby自身的lib
require_relative 'xxx_fuck' #引入同一个目录下的xxx_fuck.rb文件

(4)权限控制（两种书写方式）
:::1
class MyClass
  def method1
    #...
  end  # default is 'public'

  protected
  def method2
    #...
  end  # subsequent methods will be 'protected'

  private
  def method3
    #...
  end # subsequent methods will be 'private'

  public
  def method4
    #...
  end
end

:::2
class MyClass
  def method1
  end

  def method2
  end
  # ... and so on

  public :method1, :method4
  protected :method2
  private :method3
end

(5)对象 变量
person = Person.new
person1 = person
：：可用 person.class找到对象变量所属的class
：：可用 person.object_id 找到对象的 hashcode？
：：ruby里的每一个对象变量都不是一个object，只是一个引用或指针，指向同一个heap里面的对象，这里person1也指向了person指向的heap里面的对象
：：freeze方法，冻结对象，例如person.freeze后，也指向person的person1就不能修改这个对象
：：dup方法，复制对象,例如 person2 = person.dup,那么person2 就是全新的一个指向对象

（6）方法的返回值
没有return的时候，方法里最后一行的表达式所得值将会作为返回值

（7）方法到方法的参数
有时我们一个方法内调用另外一个方法，对于传入的参数不需要太多的了解就可以用 *args作为参数传入
def method1(*args) 
  method2(*args)
end

--------------------------------------------------------------------------------------
第三章 ： 容器 块 遍历器(containers blocks iterators) proc lambda
(1) 数组
::创建数组的两种方法，一是直接[]，二是使用Array.new

::读取数组也有多总方法 例有数组 a= ['x','y','z']
正序获取: a[0] # 'x'
到序获取: 倒数第一个由-1开始 a[-1] # => 'z'
范围获取：a[1..3] 获取下表1到3； a[1...3]获取下标1到2（不包括3）； 还可以a[-3..-1] a[4..-2]; a[start,count]从起始位置获取多少个

::%w 元素都是字符串的时候，可以用%w创建数组,如 %w(你妈 我妈 他妈 她妈)

::数组写入：a[1,2]='cat' 表示，从第一个位置开始，往后的两个下标的值用cat代替 ，例子说话吧
  a = [ 1, 3, 5, 7, 9 ]→ [1, 3, 5, 7, 9]
  a[2, 2] = ’cat’→ [1, 3, "cat", 9]
  a[2, 0] = ’dog’→ [1, 3, "dog", "cat", 9]
  a[1, 1] = [ 9, 8, 7 ]→ [1, 9, 8, 7, "dog", "cat", 9]
  a[0..3] = []→ ["dog", "cat", 9]
  a[5..6] = 99, 98 →["dog", "cat", 9, nil, nil, 99, 98]

::把数组作为stack使用
stack = []
stack.push "red"
stack.push "green"
stack.push "blue"
p stack
puts stack.pop
puts stack.pop
puts stack.pop
p stack
produces:
["red", "green", "blue"]
blue
green
red
[]

::数组作为队列（FIFO）使用
queue = []
queue.push "red"
queue.push "green"
puts queue.shift
puts queue.shift
produces:
red
green

::first()和last() 获取数组里面的头几个或最后几个的元素，返回数组，同时不会更改原数组里面的内容
array = [ 1, 2, 3, 4, 5, 6, 7 ]
p array.first(4)
p array.last(4)
produces:
[1, 2, 3, 4]
[4, 5, 6, 7]

::inspect !!
arr.inspect #=>可以转换成字符串输出,输出成"[1,2,3]"

::数据结构的总结
前端操作：放入unshift 取出shift 读取first
后端操作：放入push 取出pop 读取last

（2）hashes (associat array关联数组，maps，字典)
使用{}
：：一般情况下的hashes定义
h = { 'dog' => 'canine', 'cat' => 'feline', 'donkey' => 'asinine' }
h['dog'] # => canine

：：使用symbol(唯一键)
h = { dog: 'canine', cat: 'feline', donkey: 'asinine' }
# same as...
h = { :dog => 'canine', :cat => 'feline', :donkey => 'asinine' }
h[:dog] #=>canine

::两个字符串方法 downcase变小写; str.scan(/[\w']+/) 把str用正则匹配后返回一个数组

::Hash.new(0),用这种方式创建hash的话，所有的值都是0，方便用于计算

::sort_by (排序hash)
用法： hash.sort_by {|key,value| key or value} 用hash里面的key或者value排序，排序后返回数组，数组每个元素是一个[key,value]的数组
自己写的示例小程序
a = {
  'a'=>50,
  'b'=>20,
  'c'=>500,
  'd'=>1000,
  'e'=>10
}

arr = a.sort_by {|word,count| count}
p arr #输出:[["e", 10], ["b", 20], ["a", 50], ["c", 500], ["d", 1000]]

(3)遍历
  hash或者array.each {|each| 代码..} ；
::collect 或 map
这两个方法是遍历的同时，block里面的表达式返回值取代当前遍历的元素，常用!!

::遍历文本时可以使用 each_with_index 获得行号
  例如
  linestr.each_with_index {|line,index| puts "#{index}:#{line}"}
  each_with_index #出来的结构是|[key,valueue],index]

::inject 用于计算,内部原理是先实现each遍历然后再用参数的符号去运算
[1,3,5,7].inject(:+) # => 16
[1,3,5,7].inject(:*) # => 105

:: Enumerator去遍历 to_emu each返回emu
a = [ 1, 3, "cat" ]
h = { dog: "canine", fox: "vulpine" }
# Create Enumerators
enum_a = a.to_enum #或者 a.each也能返回enum对象
enum_h = h.to_enum
enum_a.next # 1
enum_h.next # [:dog, "canine"]
enum_a.next # 3
enum_h.next # [:fox, "vulpine"]

::each_char 遍历字符串
result = []
"cat".each_char.each_with_index {|item, index| result << [item,index] }
result # => [["c", 0], ["a", 1], ["t", 2]]

::其他用法
enum = "cat".enum_for(:each_char)
enum.to_a # => ["c", "a", "t"]

enum_in_threes = (1..10).enum_for(:each_slice, 3)
enum_in_threes.to_a # => [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10]]

::enum对象可以在new时传入block，这些代码不会马上运行，而会在你往后使用这个对象的代码时候运行
triangular_numbers = Enumerator.new do |yielder|
    number = 0
    count = 1
    loop do
      number += count
      count += 1
      yielder.yield number
    end
end
5.times { puts triangular_numbers.next } # 1 3 6 10 15

#其他常用数组集合方法!!!#
select {|a| a.length == 0} #需要集合中元素长度==0的才能留下
reject {|a| a.length == 0} #yu与上面相反，集合==0的就不要
inject {|n,i| n*i} #n是当前这个元素，i是下一个元素，这个意思是整个集合这个元素*下一个元素
join(',') #把数组每个元素用,链接起来并且返回str
delete_at(下标) #可以删除下标位置的元素

(4)块 闭包 block proc lambda
::在{}或者 do end之间，可以把它想象成匿名方法，在使用时想象成是一个额外的参数,巨大的作用是：把原来函数里一些变量可以带出函数外用，函数功能动态扩展

::block内可以读取block的变量并改写，所以要注意变量名的问题
  1.9里头，只要在||中定义可能会有重名的变量时，前面加个分号，就表明这个是闭包的变量
例如 
square = "some shape"
sum = 0
[1, 2, 3, 4].each do |value; square|
    square = value * value # this is a different variable
    sum += square
end
puts sum
puts square
produces:
30
some shape

::在函数内使用 yield 值 可以传参数给block
fabonaci 数列的block实现方法：
！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
def fib_up_to(max)
  i1, i2 = 1, 1# parallel assignment (i1 = 1 and i2 = 1)
  while i1 <= max
    yield i1
    i1, i2 = i2, i1+i2
  end
end
fib_up_to(1000) {|f| print f, " " }
puts
produces:
1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987
！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！

:: yield 同时也可以接收block返回的参数
自己写的
def testYield(num)
   if(yield num)
     '大于等于100'
   else
     '小于100'
   end
end

puts testYield(10) {|num| num*num>=100} #如果传进来的数相乘大于等于100，表达式会返回给 yield num的结果（true或者false），然后再执行条件语句

:: 函数中判断 调用函数时是否有使用block
使用block_given?

::block可以存储起来用变量去使用，在方法参数使用&符号的参数，代表接收一个block
class ProcExample
  def pass_in_block(&action)
    @stored_proc = action
  end
  def use_proc(parameter)
    @stored_proc.call(parameter)
  end
end
eg = ProcExample.new
eg.pass_in_block { |param| puts "The parameter is #{param}" }
eg.use_proc(99)
produces:
The parameter is 99
#上面的例子就是先把一个block传进对象变量里，然后用call可以调用

::写一个中间类来存储block的例子（block威力：可用在动态代码处理）
def create_block_object(&block)
  block
end
bo = create_block_object { |param| puts "You called me with #{param}" }
bo.call 99
bo.call "cat"
produces:
You called me with 99
You called me with cat

::用变量装的block对象其实都是Proc对象
直接用lambda{代码...}也能返回proc对象
    1.9里面的新写法 -> args {}
proc1 = -> arg { puts "In proc1 with #{arg}" }
proc2 = -> arg1, arg2 { puts "In proc2 with #{arg1} and #{arg2}" }
proc3 = ->(arg1, arg2) { puts "In proc3 with #{arg1} and #{arg2}" }

::参数里型餐用*变量名代表往后的多个参数
例:
proc1 = lambda do |a, *b, &block|
  puts "a = #{a.inspect}"
  puts "b = #{b.inspect}"
  block.call
end

proc1.call(1, 2, 3, 4) { puts "in block1" }
produces:
a = 1
b = [2, 3, 4]
in block1

::lambda 和 proc 差别对比
（1）在proc里头使用return,会令方法也return，方法里面的yield下面的语句就不能执行
lambda中的return则只会返回lambda，对定义或使用lambda的函数不会返回

（2）yield 或 call 传参数时，proc对参数接收能力更好，当实参个数与形参个数不同时，proc会自己调整，而lambda则必须参数一一对应

：：闭包
把闭包简单理解成"定义在一个函数内部的函数"。所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。
闭包可以用在许多地方。它的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。


#grep方法#
用法: 容器.grep(/正则匹配/) {|匹配到的元素| 执行处理}
%w(fuck duck huck).grep(/uck/) {|a| p a+$1} #$1是前面正则表达式第一个括号匹配到的串
--------------------------------------------------------------------------------------
第四章 ： 继承 模块 接口 （inheritance module mixin） 
(1)继承
：：定义子类时，用 < 父类 表示extends self变量相当与当前对象（类似java的this）
代码：
class Parent
  def say_hello
    puts "Hello from #{self}"
  end
end
p = Parent.new
p.say_hello

class Child < Parent # Subclass the parent...
end
c = Child.new
c.say_hello
produces:
Hello from #<Parent:0x0000010086b220>
Hello from #<Child:0x0000010086b108>

：：子类对象.superclass #=>父类 ；还可以用 子类.is_a?(父类)判断

：：所有类的最终父类都是object，1.9中，object.superclass是BasicObject,那是为了方便元编程

(2)Moduel 模块
：：模块不能建立实例，模块不能被继承，模块提供namepace防止各种重名问题，模块也支持mixin

：：模块 函数定义时 用 模块名.函数名去定义
module Trig
  PI = 3.141592654
  def Trig.sin(x)
    # ..
  end
  def Trig.cos(x)
    # ..
  end
end

：：先require文件 使用模块时，用 模块名.方法名 去访问方法，用 模块名::常量名 去访问常量
require_relative 'trig'
y = Trig.sin(Trig::PI/4)


（3）mixin（就是把module混进类里面，类似接口作用)
::先来个例子 在模块定义一个方法后，在类里面 include 这个模块进去后，类的实例对象可以直接使用这个方法
module Debug
  def who_am_i?
    "#{self.class.name} (id: #{self.object_id}): #{self.name}"
  end
end

class Phonograph
  include Debug
  attr_reader :name
  def initialize(name)
    @name = name
  end
end
ph = Phonograph.new("West End Blues")
ph.who_am_i? # => "Phonograph (id: 2151894340): West End Blues"

::module 比接口更优的是可动态修改，使得include这个module的类和对象可以动态改变行为

::一个导入Enumerable模组然后，重写each的例子
class VowelFinder
  include Enumerable
  def initialize(string)
    @string = string
  end
  def each
    @string.scan(/[aeiou]/) do |vowel|
      yield vowel
    end
  end
end

vf = VowelFinder.new("the quick brown fox jumped")
vf.inject(:+) # => "euiooue"

::注意module里面方法可能与类里面方法重名的情况，ruby会优先使用类本来的定义的方法

::多用module，少用继承，降低耦合

思考：java里面的interface是先定义一套标准，然后在实现类里头重写这套标准，编程时直接使用接口，具体要用哪种功能就指向哪个实现类；ruby里面是先把所有的实现功能写在module里头，然后要有某种功能的类直接include相应的module，编程的时候不会脱离class。暂时觉得编程层面ruby的方式更好，但是文档的角度来说module令结构变得更复杂
--------------------------------------------------------------------------------------
第五章 ：基本类型 (num string range regularExpression)
（1）num
123456
0d123456 #十进制
123_456 
-543
0xaabb #16进制 0b是二进制

::str to num
Integer('1') # => 1

::num运算
1 + 2#=> 3
1 + 2.0 #=> 3.0
1.0 + Complex(1,2)#=> (2.0+2i)
1 + Rational(2,3) #=> (5/3)
1.0 + Rational(2,3) #=> 1.6666666666666665

1.0 / 2 # => 0.5
1 / 2.0 # => 0.5
1 / 2 # => 0

::使用 require 'mathn' 可令除法不以小数点方式计算，以分式计算

::num一些叠加计算
3.times { print "X" }
1.upto(5) {|i| print i, " " }
99.downto(95) {|i| print i, " " }
50.step(80, 5) {|i| print i, " " }
produces:
X X X 1 2 3 4 5 99 98 97 96 95 50 55 60 65 70 75 80



（2）String
::单引号可以镶嵌双引号，两个反斜杠转义成一个
'escape using "\\"' # => escape using "\"
'That\'s right' # => That's 

 :: 双引号内使用 #{}可以在内面执行运算表达式
"Seconds/day: #{24*60*60}" # => Seconds/day: 86400
"#{'Ho! '*3}Merry Christmas!" # => Ho! Ho! Ho! Merry Christmas!
"Safe level is $SAFE" # => Safe level is 0

::使用%Q{}和%q|| 之间的字符代表是被双引号和单引号包括了

::string.strip 类似java里面trim的用法，消除两边空格

::字符串链接，可以用+ <<和concat()，用后两个效率更高

::字符串变字符数组 用str.split(//s)是英文，UTF8中文用 str.split(//u)

::使用chomp! 删除换行符

::string多行字符串的写法，使用 #注意<<后面不能有空格EOF可以是其他字符，'EOF'也可以
str =<<-EOF
    <div>fuck<div>
    <a href="fun">fun</a>
EOF

（3）range 范围
::两个点包含last，三个点不包含
1..10
'a'..'z'
0..."cat".length

::range可以用to_a方法转换成array，可以用to_enum方法转换成enumerator

::一些 range常用方法
digits = 0..9 
digits.include?(5)  #=>  true 包含吗？
digits.min #=> 0 最小值
digits.max #=> 9 最大值
digits.reject {|i| i < 5 } #=>  [5, 6, 7, 8, 9] 除了小于5的
digits.inject(:+) #=> 45 

::case and when 配合range的用法
car_age = gets.to_f
# let's assume it's 5.2
case car_age
when 0...1
  puts "Mmm.. new car smell"
when 1...3
  puts "Nice and new"
when 3...6
  puts "Reliable but slightly dinged"
when 6...10
  puts "Can be a struggle"
when 10...30
  puts "Clunker"
else
  puts "Vintage gem"
end
produces:
Reliable but slightly dinged

--------------------------------------------------------------------------------------
第六章 ：正则表达式

正则使用/xxxx/xx 的形式 创建用Regexp.new(/xxx/)或直接/xxx/ 或 %r{xxx}

::测试字符串是否match用str=~// 或者 //～=str 成功返回匹配的位置值，失败返回nil

::！～这个是不匹配 
put line if line !~ /on/ #line里面没有on的话就输出

::替换 sub(//,替换的str);gsub,sub的贪婪模式，所有匹配都会替换;sub和gsub都会返回新string
a = "cat and dog"
newa = str.sub(/cat/,'baby')
puts newa #=> baby and dog

::sub 和 gsub后面可以接收 block参数，yield出来的就是match到的字符
a = "quick brown fox"
a.sub(/^./) {|match| match.upcase } # => "Quick brown fox"
a.gsub(/[aeiou]/) {|vowel| vowel.upcase } # => "qUIck brOwn fOx"

::sub后面替换的参数可以用组pattern取代
puts "fred:smith".sub(/(\w+):(\w+)/, '\2, \1') # => simth, fred
puts "nercpyitno".gsub(/(.)(.)/, '\2\1') #=>enrcpyitno

::scan像gsub，会找到所有匹配的字符串，但是不会更改，只会把他们提取出来返回数组

::想在原数组上更改，使用sub!或者gsub! 但是如果原字符串没有匹配到，会返回nil

:: 跟在正则后面的各种参数
i 大小写忽略;o 只匹配一次;m .号不匹配换行；x 复杂模式，很长的正则里面，不会匹配空格和换行

:: match方法,//.mathc(str) 成功时返回一个MatchData对象，失败时候返回nil
name = 'Fats Waller'
/a/.match(name)#=> #<MatchData "a">

::MatchData对象 的一些方法:
pre_match 返回匹配字符的前面部分字符串
MatchData[0] 返回匹配到的字符
post_match 返回匹配字符的后面分字符串

::关键符和大多数其他的语言都一样 \s \d \w . * ? + ^ $ []{m,n} 等等

::group访问 #{MatchDate对象[第几个]},注意从1开始
md = /(\d\d):(\d\d)(..)/.match("12:50am") 
"Hour is #{md[1]}, minute #{md[2]}"  # => "Hour is 12, minute 50"

::组引用
show_regexp('Mississippi', /(\w+)\1/) # => M->ississ<-ippi


::正则高级应用，利用组函数 str =~ /()()/ [$1,$2],匹配好后会返回一个对应[$1,$2]的数组 
例:
date = "12/25/2010"
date =~ %r{(\d+)(/|:)(\d+)(/|:)(\d+)}[$1,$2,$3,$4,$5] # => ["12", "/", "25", "/", "2010"]
date =~ %r{(\d+)(?:/|:)(\d+)(?:/|:)(\d+)}[$1,$2,$3] # => ["12", "25", "2010"]

--------------------------------------------------------------------------------------
第七章 方法 函数的更多应用
::方法的预定义参数 (和PHP一样)，有传入则用实参的值，没有则用预定义的值
def cool_dude(arg1="Miles", arg2="Coltrane", arg3="Roach")
"#{arg1}, #{arg2}, #{arg3}."
end

::并且参数可以互相依赖写表达式
def surround(word, pad_width=word.length/2)
"[" * pad_width + word + "]" * pad_width
end

::模糊参数 可以用一个*变量 接收后面的或所有的参数
def varargs(arg1, *rest) #后面无论传入多少个参数都会设进rest的数组里面
"arg1=#{arg1}. rest=#{rest.inspect}"
end
另一个用法，例如直接使用父类的方法，可以不管扔进的什么参数，直接扔给父类
class Child < Parent
  def do_something(*not_used)
    # our processing
    super
  end
end

::1.9版本，模糊参数可以放到参数组的任何地方
def split_apart(first, *splat, last)
  puts "First: #{first.inspect}, splat: #{splat.inspect}, " +
    "last: #{last.inspect}"
end

::方法的最后一个参数可以用 &符号+变量，表明这个参数是一个block，并可以把这个block存储起来
class TaxCalculator
  def initialize(name, &block)
    @name, @block = name, block
  end
  def get_tax(amount)
    "#@name on #{amount} = #{ @block.call(amount) }"
  end
end
tc = TaxCalculator.new("Sales tax") {|amt| amt * 0.075 }
tc.get_tax(100) # => "Sales tax on 100 = 7.5"
tc.get_tax(250) # => "Sales tax on 250 = 18.75"

::类里面调用方法时不写明调用者，默认使用self，就是对象本身

::所有的方法都会返回参数，当你没有写return时候，方法里面最后一条表达式的值就是返回值

::1.9在传参的时候也可以使用 *[]作为模糊参数，十分方便
def five(a, b, c, d, e)
"I was passed #{a} #{b} #{c} #{d} #{e}"
end
five(1, 2, 3, 4, 5 ) #=>"I was passed 1 2 3 4 5"
five(1, 2, 3, *['a', 'b']) #=>下面的如此类推，总之能够传进来
five(*['a', 'b'], 1, 2, 3)
five(*(10..14))
five(*[1,2], 3, *(4..5))

::匹配最短结果（不贪婪）用?
.*? 0次以上最短匹配
.+? 1次以上最短匹配

--------------------------------------------------------------------------------------
第八章 表达式 妙用
::链式表达式
a = b = c = 0 # => 0
[ 3, 1, 7, 0 ].sort.reverse # => [7, 3, 1, 0]

::if 或者 case 的确认分支最后一个表达式可以作为返回值
例
song_type = if song.mp3_type == MP3::Jazz
              if song.written < Date.new(1935, 1, 1)
                Song::TradJazz
              else
                Song::Jazz
              end
            else
              Song::Other
            end

rating = case votes_cast
         when 0...10 then Rating::SkipThisOne
         when 10...50 then Rating::CouldDoBetter
         else Rating::Rave
         end

::每一个运算符可以看成是一个方法，例如a*b可以看作 a执行*这个方法，传入b这个参数
a, b, c = 1, 2, 3
a * b + c # => 5
(a.*(b)).+(c) # => 5

::由于符号都可以是一个object，你可以在自己的类里面定义各种符号的运算（像C++）
class ScoreKeeper
  def initialize
    @total_score = 0
    @count = 0
  end
  def <<(score)
    @total_score += score
    @count += 1
    self
  end
  def average
    fail "No scores" if @count == 0
    Float(@total_score) / @count
  end
end
scores = ScoreKeeper.new
scores << 10 << 20 << 40
puts "Average = #{scores.average}" #=>23.333333333 这个例子是每次调用完<<之后都会把当前对象返回除去，所以可以<<23<<30链式调用

::重写[]符号的例子，当使用时 对象[参数1，参数2]=值，在方法里头会把值作为最后一个参数传入
class SomeClass
  def []=(*params)
    value = params.pop
    puts "Indexed with #{params.join(', ')}"
    puts "value = #{value.inspect}"
  end
end
s = SomeClass.new
s[1] = 2
s['cat', 'dog'] = 'enemies'
produces:
Indexed with 1
value = 2
Indexed with cat, dog
value = "enemies"

::！！！！调用底层操作系统的命令行！！！！
使用``反单引号或者%x{命令}可以执行系统命令！
‘date‘ # => "Tue Nov 9 18:45:39 CST 2010\n"
‘ls‘.split[34] # => "foreword3.pml"
%x{echo "hello there"} # => "hello there\n"

可以把参数变量传入系统命令！！同样是在反单引号里面使用#{}
for i in 0..3
  status = ‘dbmanager status id=#{i}‘
    # ...
end

::方法= 的类型中现在ruby只会返回存入参数，不会理会return
class Test
  def val=(val)
    @val = val
    return 99
  end
end
t = Test.new
a = (t.val = 2)
a # => 2

::在ruby中，交换两个数的值不用中间变量
a = 1
b = 2
a, b = b, a #=> b=1 a=2

::一些小语法糖果
a = 1, 2, 3, 4 # a=[1, 2, 3, 4]
b = [1, 2, 3, 4] # b=[1, 2, 3, 4]
a, b = 1, 2, 3, 4 # a=1, b=2
c, = 1, 2, 3, 4 # c=1
a, b, c, d, e = *(1..2), 3, *[4, 5] # a=1, b=2, c=3, d=4, e=5
a, *b = 1, 2, 3 # a=1, b=[2, 3]
a, *b = 1 # a=1, b=[ ]
*a, b = 1, 2, 3, 4 # a=[1, 2, 3], b=4
c, *d, e = 1, 2, 3, 4 # c=1, d=[2, 3], e=4
f, *g, h, i, j = 1, 2, 3, 4 # f=1, g=[ ], h=2, i=3, j=4
first, *, last = 1,2,3,4,5,6 # first=1, last=6

::ruby没有++ --，用+=和-=就好啦

::ruby里面 除了nil和false之外，一切对象都是true

::&&的优先级比||要高

::||=的作用，
a ||= 123 # 如果a没有值，它会被设成123，如果有了则不变

::defined? 后面跟一个任意object，如果该object有意义，则会返回一个描述，否则会返回nil

::有三目运算符的啦 cost = duration > 180 ? 0.35 : 0.25

::case 值
 when 范围
 else 以外
 end 

::while end

::until条件 then  end （与while相反，条件取反时才做）

::做几次
3.times do
print "fuck fuck fuck"
end

::each
[1,2,3].each{|e|
p e
}

::for..fn
for xx in 集合{
    循环要做的事
}

::break redo（当前条件循环再执行一次） next（相当于continute跳过这次循环）

(2)变量的范围
在block内定义的变量，外部不能访问，除非变量之前就存在于外部

::ruby1.9引入了block-local变量的概念，在block参数前面加分号，则这个变量即使在block域外定义了，也不会影响到block域外的值
例:
square = "yes"
total = 0
[ 1, 2, 3 ].each do |val; square|
    square = val * val
    total += square
end
puts "Total = #{total}, square = #{square}"
produces:
Total = 14, square = yes

--------------------------------------------------------------------------------------
第九章 Exception catch throw
(1)自写expection类要集成StandardError

(2)exception 格式，使用begin rescue和and，rescue后跟exception名称，代码里面的$!全局变量是一个例外对象，raise相当与throw可以引发例外,ensure相当与finally(无论如何都要执行的语句)
require 'open-uri'
page = "podcasts"
file_name = "#{page}.html"
web_page = open("http://pragprog.com/#{page}")
output = File.open(file_name, "w")
begin
  while line = web_page.gets
    output.puts line
  end
  output.close
rescue Exception
  STDERR.puts "Failed to download #{page}: #{$!}"
  output.close
  File.delete(file_name)
  raise
ensure
  puts "fuck exception"
end

::你也可以不用$!变量，在rescue Exception=>bang 使用变量名，bang将会成为例外变量

::exception变量的一些方法 $!.message，输出例外信息；$!.backtrace 输出例外位置（等同与$@变量）

::retry写在rescue里面可以重新执行begin里面的语句，例如可以要她 sleep 10秒然后再执行回begin的语句

::rescue其实类似if语句，例如前面的语句发生例外，就可以执行后面的值，有时可以用来设定默认值
v = Integer(val) rescue 5 #如果传入的val是int类型，发生例外就取默认值5

::如果整个方法里面都是以begin end结尾的话，begin end可以省略

(3)raise
raise  # 会抛一个runtime error
raise 'message' #抛出错误信息
raise Exception类 #直接抛出错误类
raise 类 '信息' caller #抛出完整的异常

（4）catch throw 有时遇到某种情况，例如会重大伤害到数据，就可用于跳出循环或离开语句
word_list = File.open("wordlist")
word_in_error = catch(:done) do
result = []
while line = word_list.gets
  word = line.chomp
  throw(:done, word) unless word =~ /^\w+$/
  result << word
end
puts result.reverse
end
if word_in_error
  puts "Failed: '#{word_in_error}' found, but a word was expected"
end
produces:
Failed: '*wow*' found, but a word was expected  #result的值不会被执行

--------------------------------------------------------------------------------------
第十章 IO
所有的IO类都是从File或者BasicSocket继承而来

（1）读取文件
file = File.open("filename","权限符") 
file = File.join(Rails.root,'config','weibo.yml') #!!这样可以方便读取路径+文件
file.close
::权限符跟php一样，有r(默认) r+（读写） w（只写，清空原有数据） w+（读写，清空原有数据，不存在文件则创建） a（只写，后面追加） a+ （读写，后面追加） b（读二进制文件）

::和File.new不同，File.open()后面可以使用block，参数就是这个file对象，并且block代码运行完之后可以自动关闭对象，new则不行

::逐个字符读出 file.each_byte
File.open("testfile") do |file|
  file.each_byte.with_index do |ch, index|
    print "#{ch.chr}:#{ch} "
    break if index > 10
  end
end
produces:
T:84 h:104 i:105 s:115 :32 i:105 s:115 :32 l:108 i:105 n:110 e:101

::file.each_line(){|line|} ，逐行读，也可以使用参数，遇到参数这个字符就自动换行
File.open("testfile") do |file|
  file.each_line("e") {|line| puts "Got #{ line.dump }" }
end
#也可以使用each_line.with_index {|line,index| do xxx}

::可以直接用IO这个类把一个文件读入一个string或者array
# read into string
str = IO.read("testfile")
str.length # => 66
str[0, 30] # => "This is line one\nThis is line "
# read into an array
arr = IO.readlines("testfile")
arr.length # => 4
arr[0]# => "This is line one\n"

(2)写入文件
::十分简单，用file资源puts就可以写入到文件
File.open("output.txt", "w") do |file|
  file.puts "Hello"
  file.puts "1 + 2 = #{1+2}"
end

::写入二进制码（三种方法）
str1 = "\001\002\003" # => "\x01\x02\x03"
str2 = ""
str2<< 1 << 2 << 3# => "\x01\x02\x03"
[ 1,2, 3 ].pack("c*") # => "\x01\x02\x03"

(2.1)其他操作
::File.rename("before.txt","after.txt")

::复制粘贴，用fileutils包方便
require 'fileutils'
FileUtils.cp("from","to")
FileUtils.mv("from","to")

::删除 File.delete("filename")

::目录Dir，和File一样，open时直接使用区块就不用创建对象不用close
Dir.open('/usr/bin'){|dir| #dir就是内建block对象，block执行完后变量自动消除
  dir.each{|name|
    puts name
  }
}

#!!把目录下的所有目录名称获取成一个数组
Dir.glob("#{Rails.root}/app/*")

（3）网络IO，各种类 UDPSocket TCPSocket等等
::tcp
require 'socket'
client = TCPSocket.open('127.0.0.1', 'www')
client.send("OPTIONS /~dave/ HTTP/1.0\n\n", 0) # 0 means standard packet
puts client.readlines
client.close

::http
require 'net/http'
http = Net::HTTP.new('www.pragprog.com', 80)
response = http.get('/titles/ruby3/programming-ruby-3')
if response.message == "OK"
  puts response.body.scan(/<img alt=".*?" src="(.*?)"/m).uniq[0,4]
end

::注意lib下面的net/包，还有ftp pop stmp等各种协议提供使用

::使用open-uri读取网页
require 'open-uri'
page = open('www.163.com').read
if page =~ %r{<title>(.*?)</title>} #使用正则读出标题
  puts "Title is #{$1.inspect}"
end

::使用强大的hpricot库去方便读取http的各种标签（需要用gem安装）
require 'open-uri'
require 'hpricot'
page = Hpricot(open('http://pragprog.com'))
puts "Page title is " + page.at(:title).inner_html
# 将div id=copyright的p读出来
puts page.at('div#copyright p')
# 将第二条超链接读出来
puts "\nSecond hyperlink is"
puts page.at('div#site-links a:nth(2)')
produces:
Page title is The Pragmatic Bookshelf
<p>
Copyright &copy; 1999&#8211;2010 The Pragmatic Programmers, LLC.
</p>
Second hyperlink is
<a href="http://pragprog.com/community">Connect!</a>

--------------------------------------------------------------------------------------
第十一章 线程 纤维 (threads fibers)
fiber是ruby1.9支持的线程控制,方便了使用线程，不再需要像过去般继承各种类

::fiber常用于从一些有序序列里产生值给程序使用,Fiber对象处处可用，并且block里面的变量都可以保存，在new时的block里yield出来的参数就是使用这个fiber对象时的值，使用时用fiber对象.resume
例子：产生10个能被2除尽不能被3除尽的数
twos = Fiber.new do
  num = 2
  loop do
    Fiber.yield(num) unless num % 3 == 0
    num += 2
  end
end
10.times { print twos.resume, " " }
produces:
2 4 8 10 14 16 20 22 26 28

::thread，ruby1.9开始使用系统来产生线程，但ruby的thread大部分都是unsafe的，所以ruby使用了“可以产生多线程，单同一时间只执行一个线程”的方式。。。
一个线程会共享拥有所有全局变量，对象变量
例子，创建三个线程去获取信息
require 'net/http'
pages = %w( www.rubycentral.org slashdot.org www.google.com )
threads = []
for page_to_fetch in pages
  threads << Thread.new(page_to_fetch) do |url| #创建线程对象，放进thread数组，放进去的page_to_fetch变量会yield回到后面block中的url
    http = Net::HTTP.new(url, 80)
    print "Fetching: #{url}\n"
    resp = http.get('/')
    print "Got #{url}: #{resp.message}\n"
  end
end
threads.each {|thr| thr.join } #这一行保证了是三个线程运行完毕后，主线程才关闭 
produces:
Fetching: www.rubycentral.org
Fetching: slashdot.org
Fetching: www.google.com
Got www.google.com: OK
Got slashdot.org: OK
Got www.rubycentral.org: OK

：：Thread一些静态方法,Thread.current获取当前线程;Thread.list获取程序中的线程列表 Thread.status Thread.alive Thread.priority优先级

：：不同的Thread（包括主线程）也共享同一个变量的例子,thread可以在Thread.current[xxx]里面保存一些变量，外面直接用thread对象[]访问即可
count = 0
threads = []
10.times do |i|
  threads[i] = Thread.new do
    sleep(rand(0.1))
    Thread.current[:mycount] = count
    count += 1
  end
end
threads.each {|t| t.join; print t[:mycount], ", " }
puts "count = #{count}"
produces:
7, 0, 8, 6, 5, 4, 1, 9, 3, 2, count = 10

::Thread的exception与abort_on_exception 和$DEBUG设置有关，thread中raise的exception会在thread join的时候被捕获

--------------------------------------------------------------------------------------
第十二章 单元测试 (unit testing)
1.8用的是 Nathaniel Talbott’s Test::Unit framework 
1.9用的是 Ryan Davis’ MiniTest  MiniTest::Unit
用,Test::Unit例子
require_relative 'romanbug'
require 'test/unit'
class TestRoman < Test::Unit::TestCase
  def test_simple
    assert_equal("i", Roman.new(1).to_s)
    assert_equal("ix", Roman.new(9).to_s)
  end
end

：：assert_raises(RuntimeError) { Roman.new(5000) }  #断言exception

ruby -r debug debug-options programfile program-arguments

--------------------------------------------------------------------------------------
第十三章 Ruby Seting
::解决了gem安装慢的问题（或根本安装不了）
先上github下载gem-fast
然后进入解压gem-fast的目录运行 gem install gem-fast.gemspec
装好后在gem源中加入 http://gems.github.com/ (gem sources -a http://gems.github.com)
然后飞速下载使用gem吧！
中途遇到zlib::gzib问题，进gems/ruby版本目录/cache目录下把spece.xxx, lastxxx两个包给删了在更新下就可以
::gem安装包
$ gem query --details --remote --name-matches build #查找操作 details显示详细，remote表示远程库下载 name-mathces表示找有没符合正则"build"的包
$ gem list --details --remote --all builder #列出操作，列出显示所有有builder的包
$ gem install builder #安装builder 包
$ gem environment gemdir #查看配置文件夹
$ gem server #可以开启gem服务器，端口8808，可以方便查看文档
$ gem update --system
$ gem install builder --version '< 1' #指定安装version
$ gem build anagram.gemspec #从文件建立gem

#删除原有gem source gem source -r http://rubygems.org/ gem source -r http://production.s3.rubygems.org/   #增加新source源 gem source -a http://gems.rubyonrails.org
::使用gem,假设已经下了builder,直接在程序中 require 'builder'就好

::encoding问题，假设一个文件原来是iso-8859-1,而我们操作系统是utf-8，我们可以在他打开的时候置顶两个编码让系统适应
f = File.open("iso-8859-1.txt", "r:iso-8859-1:utf-8")
puts f.external_encoding.name
line = f.gets
puts line.encoding
puts line
produces:
ISO-8859-1
UTF-8
olé

::编写，rdoc,在方法或类上面使用 =begin rdoc  =end
例：
=begin rdoc
this method xxxx
=end
def fuck
  #code...
end

#国内镜像#
$ gem sources -a http://ruby.taobao.org/
$ gem install foo
--------------------------------------------------------------------------------------
第十四章 反射 元编程
先理顺祖先链:

BasicObject
    |
Kernel
    |
Object
    |
Class

假设有一个自己创建的MyClass:
MyClass.class => Class
MyClass.superclass => Object 
Class.class => Class 
Object.class => Class 
Object.superclass => BasicObject 
Kernel.class => Module 
Class.superclass => Module 
Module.class => Class 
Module.superclass => Object

方法会先从祖先链由下到上查找，查到了就执行

#!!!!!! ancestors()#
MyClass.ancestors #此方法可以检查出祖先链由下到上的顺序
 
(1)判断对象是否某个类或子类的各种方法
o.instance_of? c #判断o.class==c
o.is_a? c  #判断o是否c的子类,如果c是模块，则判断o.class有没include c
o.kind_of? c #同上

（2）eval方法（同js），强大的动态执行方法，可做外壳，扩展等
eval 'p "日你妈"' 

::可以在eval方法第二个参数设定binding变量，指定eval代码的上下文，如：
eval('@t',t.binding) #执行的是t这个对象里面的@t变量

::还可以直接使用instance_eval或者class_eval去指定具体调用哪个上下文的变量
t.instance_eval('t')
String.class_eval('def len; size; end')

::一些返回变量名称的方法！
global_variables #返回全局变量
local_variables #返回本地变量
Point::ORIGIN.instance_variables #Point这个类的对象变量 @x
Point.class_variables #Point这个类的类变量 @@y
Point.constants #Point这个类的静态常数 VERSION

::设置或者获取对象，类的各种变量
o.instance_variable_set(:@x,0) #设定o对象的变量为0
o.instance_variable_get(:@x)
Object.class_variable_set(:@@y,1)
Object.class_variable_get(:@@y)
Math.const_set或get  #类变量的举例

::获取对象的方法名
o.methods
o.public_methods(<false>) #如果加false则不从父类找
o.protect_methods
o.private_methods
o.singleton_methods

::获取Method对象
"s".method(:reverse)
String.instance_method(:reverse)

#!!!! 元编程重要的三个方法！ send, define_method, method_missing
::调用方法，使用send
例如直到"s"对象有个reverse的方法后，可以：
"s".send :reverse #调用
"s".send(:reverse,*args) #send第一个参数是方法名，后面则是调用这个方法的参数

::define_method在类中动态创建方法
Moduel#define_method(),他会自己动态创建一个实例方法

class MyClass
    define_method :new_method do |args1|
    	p "this is defined by #define_method and the args is #{args1}"
    end
end

m = MyClass.new
m.new_method(123)

::method_missing()方法
Kernel#method_missing, 当实例调用了没有声明的方法时，就会激活这个方法

class Lawyer
    def method_missing(method, *args)
        p "you called: #{method}(#{args.join(', ')})"	
	p "(you also gave me a block)" if block_given?
    end
end

l = Lawyer.new
l.fuck

#!!!!!########################################

::序列化对象
例如有个对象c
写到文件：
File.open("object","w+") {|f|
  Marsha1.dump(c,f)
}

读取回来
File.open("object","r") {|f|
 o= Marsha1.load(f)
}
-----------------------------------------------------------------------
补充
一. Time和Date
（1）Time 使用C语言的原生时间戳
t = Time.new (或Time.now)
p t #打印现在时间
一些方法获取各种时间参数
t.year t.month t.day t.hour t.min t.sec t.wday t.mday t.yday t.zone
获取timestamp
t.to_i #从1970年算起的秒数

::指定的方式建立Time对象
t = Time.mktime(2006,5,15,05,03,30)

::Time计算
可以直接两个Time对象+-返回float 秒数

::时间输出格式化
t = Time.new
p t.strftime("%Y/%m/%d %H:%M:%S")

::解析字符串（字符串转回Time对象）
Time.parse("Sat Apr 15 11:50:30 +8000 2006")

::timestamp转换成时间格式
Time.at(timestamp)

二. $SAFE
0 默认,受污染也不检查
>=1 不允许潜在威胁
>=2 禁止从外部科协地方读入程序
>=3 所有新创建的对象都被认作受污染
>=4 所有对象都不能够修改

三. 猴子补丁
类在定义过后，可以再其他地方增添 取消类的方法，系统类也行
如 
class foo
  def p1
    #...
  end
end

然后在其他地方可以继续定义
class foo
  def p234
    #...
  end
end
这样的话，foo这个类相当于增加了方法，即使存在的对象也可以直接使用增添的方法。或在想增加String Array等系统类方法时也可以用这种方式

::在类内部的方法别名和取消已定义的方法
alias 别名 原名
undef 方法名
remove_method() #只取消本类的方法名，不取消父类


------------------------------------------------------
附录:


依赖包:sudo apt-get install build-essential bison openssl libreadline6-dev curl git-core zlib1g zlib1g-dev libssl-dev libyaml-dev libsqlite3-0 libsqlite3-dev sqlite3 libxml2-dev libxslt-dev autoconf libc6-dev ncurses-dev

rvm: 
$ sudo apt-get install git-core
$ bash -s stable < <(curl -s https://raw.github.com/wayneeseguin/rvm/master/binscripts/rvm-installer)

#修改~/.bashrc 文件，加入
# add rvm
if [[ -s "$HOME/.rvm/scripts/rvm" ]]  ; then 
    source "$HOME/.rvm/scripts/rvm" ;
fi
#rvm install ruby-1.8.7 --head --docs
#rvm remove xxxx
#rvm list # list known可以查看远程一共有哪些版本
#rvm use xxxx --default
#嫌慢可先把源码包复制到.rvm/archives下面再install

#在~/.gemrc 加入
gem: --no-ri --no-rdoc 会另geminsatal速度更快

#rvm其他应用
rvm list know #列出所有ruby已知版本
rvm use 1.9.3 --default #设置为系统默认ruby版本

#gemset 独立虚拟的gem环境，每一个gemset都是相互独立的,如果你在1.9.3建立了一个rails3的gemset, 切换到1.8.7那么rails3这个gemset也会不存在
rvm gemset create rails3 #创建gemset
rvm use 1.9.2@rails3 #切换到1.9.2和rails3的gemset
rvm gemset list #列出所有的gemset
rvm gemset emty 1.9.2@rails3 #清空这个gemset所有的gem
rvm gemset delete rails3 #删除一个gemset

#.rvmrc使用设置项目默认的ruby版本和gemset
例如有一个rails项目，在这个项目下面创建一个.rvmrc的文件，然后加入：
rvm use 1.9.3@rails2 
然后不管你当前ruby版本是什么这个目录下的项目运行都会使用文件内设置的版本和gemset

#有时候gem install rails 之后系统提示找不到rails的话，创建一个软链接就好了
ln -s /home/jas/.rvm/gems/ruby-1.9.3-p125/gems/railties-3.2.2/bin/rails /usr/local/bin/rails
------------------------------------
编程习惯
把数据插入到string变量的时候，不要使用+，用<<追加,例如:
html=''
html<< Some String from web

-----------------------------------
Ruby 自己的 ri 太慢，装个 fastri 就爽多了。 
gem install fastri
以后就可以用qri

----------------------------------
Ruby benchmark ruby提供的benchmark测试程序性能

require 'benchmark'
    Benchmark.bm do |b|
    	b.report "descript" do    		
	    10000.times do xxxx
    	end
    end



-----------------------------------
使用ruby链接Mysql
gem install mysql2
require 'mysql2'
c = Mysql2::Client.new(username:'ff', password:'ff',localhost:'xx',database:'sss')
r = c.query('select * from fucking')
r.each {|row| do sth}
#可以设置r.each(:symbolize_keys => true, :as => :array ) {do xxx}

#一些预定义的方法
Mysql2::Client.default_query_options
which defaults to:
{:async => false, :as => :hash, :symbolize_keys => false}
that can be used as so:
# these are the defaults all Mysql2::Client instances inherit
Mysql2::Client.default_query_options.merge!(:as => :array)
or
# this will change the defaults for all future results returned by the #query method _for this connection only_
c = Mysql2::Client.new
c.query_options.merge!(:symbolize_keys => true)
or
c = Mysql2::Client.new
c.query(sql, :symbolize_keys => true)

------------------------------------
##!! 委托模式
extend Forwardable
def_delegator 委托对象，委托方法1, 委托方法2

class A
    extend Forwardable
    def_delegator @yy, :fuck
    def initialize(yy)
	@yy = yy
    end
end

A.new(yy).fuck() #会调用@yy的fuck方法
